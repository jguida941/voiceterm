# Theme + Overlay Studio Plan (No-Code, Full-Surface Customization)

Date: 2026-02-17  
Status: Activated planning track (execution mirrored in `dev/active/MASTER_PLAN.md` MP-148..MP-151, MP-161..MP-167, MP-172..MP-182)  
Scope: Full in-overlay editor so users can customize nearly every overlay aspect
without writing code

`dev/active/MASTER_PLAN.md` remains the canonical execution tracker.
Implementation starts only through linked MP items and must preserve existing
HUD/theme behavior until non-regression gates pass.

## Product Goal

Users should be able to open a full editor inside VoiceTerm and customize:

- theme colors and token palettes
- borders, glyph/icon packs, and text styles
- layout types and responsive breakpoints
- graphs/widgets and what data they show
- animations and transition behavior
- interaction behavior (hotkeys, mouse, visibility rules)
- accessibility modes and readability controls

No coding should be required for common customization workflows.

## Product IA Boundary (Required)

Theme customization must be a dedicated `Theme Studio` mode, not a subpage
inside general Settings.

- `Theme Studio` owns all visual/design surfaces:
  - tokens, layout, widgets, motion, visual behavior, voice-state scenes
  - notifications/toasts
  - command palette and autocomplete visual surfaces
  - accessibility style policies and profile routing
- `Settings` owns non-theme runtime operations:
  - auto-voice/send-mode/macros toggles
  - sensitivity, latency-display mode, mouse mode
  - backend/pipeline, close, quit
- Keep quick preset actions (`ThemePicker`, quick cycle) as shortcuts, but deep
  editing must route to `Theme Studio`.
- Out-of-scope boundary: Theme Studio controls VoiceTerm-owned overlays/HUD/editor
  surfaces, not arbitrary styling of upstream CLI output generated by Codex/Claude.

This boundary prevents control sprawl and keeps Studio as one coherent system.

## Re-Audit Summary (Codebase + UX Gaps)

### Strong today

- runtime theme switching, picker, and settings wiring exist:
  - `src/src/bin/voiceterm/theme_ops.rs`
  - `src/src/bin/voiceterm/theme_picker.rs`
  - `src/src/bin/voiceterm/settings_handlers.rs`
- color capability fallback already exists:
  - `src/src/bin/voiceterm/config/theme.rs`
  - `src/src/bin/voiceterm/color_mode.rs`
- HUD data modules already have a registry pattern:
  - `src/src/bin/voiceterm/hud/mod.rs`

### Current blockers for full no-code editor

- theme system is enum/static-palette centered:
  - `src/src/bin/voiceterm/theme/mod.rs`
  - `src/src/bin/voiceterm/theme/palettes.rs`
- layout and animation are hardcoded in formatter/util modules:
  - `src/src/bin/voiceterm/status_line/layout.rs`
  - `src/src/bin/voiceterm/status_line/animation.rs`
- settings UI is flat, not a multi-page editor:
  - `src/src/bin/voiceterm/settings/items.rs`
  - `src/src/bin/voiceterm/settings/state.rs`
- active overlay renderer is custom ANSI row redraw, not a structured scene graph:
  - `src/src/bin/voiceterm/writer/state.rs`
  - `src/src/bin/voiceterm/writer/render.rs`
- multiple visual surfaces are still hardcoded outside a central style resolver:
  - `src/src/bin/voiceterm/banner.rs`
  - `src/src/bin/voiceterm/help.rs`
  - `src/src/bin/voiceterm/progress.rs`
  - `src/src/bin/voiceterm/audio_meter/format.rs`
  - `src/src/bin/voiceterm/icons.rs`

## Is "Full GUI Editor in Overlay" Possible?

Yes, with boundaries:

- possible:
  - full-screen in-terminal editor flows
  - multi-page visual editing with live preview
  - rich controls (lists, sliders, toggles, pickers, reorder)
- not universally possible inside the terminal itself:
  - forcing actual font family changes globally
  - true pixel-canvas drag/drop UIs
  - desktop-window-level chrome effects

We can still make this feel GUI-like by building a full in-overlay Studio with
structured widgets and preview panes.

## Missing User Stories to Add (Delta From Prior Plan)

The prior plan still missed key no-code stories. Add these explicitly:

1. "I want to remap every key/button action without editing files."
2. "I want to choose what HUD modules appear and in what order."
3. "I want different looks for idle, recording, processing, responding."
4. "I want to change graph type, scale, smoothing, and thresholds."
5. "I want to customize startup splash and overlay labels/messages."
6. "I want to save style profiles per backend/project."
7. "I want reduced motion/high contrast/ASCII-safe presets."
8. "I want undo/redo and rollback if I break the style."
9. "I want import/export/share style packs safely."
10. "I want font-like control from inside the editor."
11. "I want to style toast notifications and their severity states."
12. "I want command palette and autocomplete visuals to match my style pack."
13. "I want dashboard and multi-panel surfaces themed with the same system."
14. "I want every new visual feature to be style-pack addressable on day one."
15. "I want to click/inspect any UI element and jump directly to its style controls."

## Font Customization Strategy (Practical, Honest)

Inside terminal constraints:

- provide typography-like controls in overlay:
  - bold/dim/italic/underline policy per component
  - glyph packs (Unicode, ASCII-safe, nerd-font-friendly)
  - spacing/density scale
  - icon density and separators

Host-terminal adapter track (optional):

- WezTerm adapter via runtime config overrides
- Kitty adapter via remote control commands
- iTerm2 adapter via profile-related escape mechanisms
- xterm-compatible font operations only where enabled

This gives users a "fonts" experience where supported, with safe fallback when
not supported.

## Framework Capability Audit (What Rust Stack Enables)

### Ratatui (already in repo)

- current dependency is `ratatui = 0.26` with `default-features = false` and
  backend feature `crossterm` only (`src/Cargo.toml`), so parity must be
  tracked against that shipped capability set.
- supports rich layout composition, constraints, and many widgets (charts,
  sparklines, bars, tables, tabs, scrollbars, paragraph/list/block/canvas) and
  custom widget extensions.
- symbol families (`bar`, `block`, `border`, `braille`, `line`, `marker`,
  `scrollbar`, `shade`) are available and should be surfaced as style-pack
  options, not hardcoded glyph choices.
- strong fit for Studio editor surfaces and layout builder previews.
- keep PTY-safe ANSI transport while using Ratatui concepts for composition.

### Crossterm (already in repo)

- supports advanced input events including mouse/focus/paste/resize.
- supports enhanced keyboard input flags and synchronized terminal updates,
  which should be exposed as capability-aware interaction/render options.
- supports truecolor (`Rgb`) plus `AnsiValue` indexed colors, enabling
  capability-aware color strategy per terminal.
- enables a richer editor interaction model without leaving terminal.

### TachyonFX (candidate, referenced in roadmap)

- supports effect composition (`parallel`/`sequence`) and can drive richer
  state transitions.
- useful for no-code motion presets and channel-level animation controls.

### Ecosystem opportunities

- third-party Ratatui widgets (tree, editors, popups, etc.) can accelerate Studio.
- style packs can mirror proven patterns from Helix/Zellij/VS Code ecosystems.

## Framework-Derived Delta (Additions Required)

1. Explicit Ratatui built-in parity matrix: every built-in widget/symbol family
   we adopt must map to style IDs and Studio controls (or a tracked parity task).
2. Explicit legacy-surface migration: startup splash, help/settings/picker,
   progress visuals, calibration visuals, and icon/spinner sets must route
   through `StylePack`.
3. Explicit terminal graphics/texture track: symbol textures first, then
   Kitty/iTerm2 image protocols where supported, with guaranteed text fallback.
4. Explicit TachyonFX motion graph controls: no hardcoded animation constants
   after parity phase; motion presets must be data-driven.
5. Explicit widget-pack architecture: first-party and optional third-party
   widgets need registry + allowlist + style binding contracts.

## Additional Framework Opportunities (Google/Web Audit)

Primary opportunities that can strengthen a no-code "wow" editor:

1. `tui-widgets` suite adoption path (`tui-popup`, `tui-prompts`,
   `tui-scrollview`, `tui-big-text`, `tui-qrcode`) to accelerate Studio controls.
2. `tui-textarea` or editor widgets for richer in-Studio text/token editing.
3. `tui-tree-widget` for layout tree/component hierarchy editing UI.
4. `throbber-widgets-tui` for expanded spinner libraries and motion presets.
5. `ratatui-image` for protocol-aware image rendering (sixel/kitty/iTerm2) as
   optional texture/image layer.
6. `ratatui-splash-screen` for image-based startup branding variants.
7. `tui-markdown` for styleable in-app docs/help/preview rendering.
8. `tuirealm` as optional architectural layer if we need heavier component/event
   orchestration than current custom overlay dispatch.

Adoption guardrail:

- treat these as optional capability packs behind registry + allowlist + parity
  tests; no dependency may bypass style IDs, resolver paths, or Studio mapping.

## Full Customization Surface (Target)

### A) Visual tokens

- full semantic palette per state and component
- border sets per section
- icon/glyph packs and fallback packs
- text style policy (bold/dim/italic/underline per token)
- background styles (solid, gradient-like stepped palettes where supported)

### B) Layout editor

- choose layout template (classic, compact, pro, split, minimal)
- container tree editing (`row`, `column`, `grid`, `stack`)
- module reorder and docking
- responsive breakpoints and per-width variants
- spacing scale, padding scale, density presets

### C) Widget editor

- enable/disable widget modules
- choose widget types for metrics:
  - sparkline, bar, line, gauge, dots, heartbeat, compact text
- configure each widget:
  - color mapping
  - scale mode
  - history window length
  - smoothing policy

### D) Motion editor

- animation channel toggles (pulse/spinner/heartbeat/transitions)
- speed, easing, and frame-set selection
- per-state animation policy
- reduced-motion one-click policy

### E) Behavior editor

- auto-hide and collapse rules
- update cadence and refresh policy
- message verbosity and dwell durations
- panel show/hide triggers by state

### F) Input + interaction editor

- full keybind remapping
- mouse click zones and behavior policies
- focus order and navigation style

### G) Accessibility editor

- high-contrast and color-blind safe modes
- reduced motion mode
- ASCII-safe glyph mode
- large-spacing mode
- readability warnings/contrast checker

### H) Profile editor

- per-backend style profile
- per-project style profile
- time-based or context-based profile switching (later phase)

### I) Notification + feedback surfaces

- toast style families (info/success/warn/error)
- position policy and density
- dwell animation style presets
- history-panel visual treatment

### J) Command + discovery surfaces

- command palette chrome and match highlighting
- autocomplete dropdown style and focus state
- search/filter row and hint styling
- action-group visual hierarchy

### K) Voice-state scene editor

- per-state visual scenes (idle/listening/processing/responding)
- scene-specific animation/easing policy
- state badges and transition cues
- low-motion alternates per state

### L) Component skinning (Ratatui + custom surfaces)

- button skins (all control rows and action buttons)
- tabs, lists, tables, tree nodes, scrollbars
- popups/modals/tooltips and overlay frames
- input fields, caret, selection highlights, and placeholders
- separators/dividers/badges/chips and status pills

### M) Interaction state matrix

- state variants per component:
  - default, hover, focused, pressed, selected, disabled
  - idle, listening, recording, processing, responding
  - success, warning, error, muted
- visual + animation deltas per state transition

### N) Composition and layering rules

- overlay stack ordering and z-layer policy (HUD, toasts, picker, Studio pages)
- backdrop/occlusion policies for modal and non-modal surfaces
- terminal-width breakpoints with per-layer fallback behavior

### O) Startup, onboarding, and calibration surfaces

- startup splash/logo/tagline style policy
- help/settings/theme-picker chrome consistency policy
- calibration meter/wizard surface styling and thresholds presentation
- startup progress/status messaging style policy

### P) Progress and queue feedback surfaces

- determinate bar families and fill styles
- indeterminate spinner/frame packs with speed/easing controls
- queue-depth badge styles and severity mapping
- inline status hint style routing into toast-equivalent surfaces

### Q) Texture and image surfaces

- symbol-based textures (`shade`, `braille`, `block`) for universal terminals
- capability-gated image/textures for compatible terminals (Kitty/iTerm2 paths)
- fallback chain (`image -> texture symbols -> plain`) enforced in resolver

### R) Ratatui widget + symbol parity controls

- Studio controls for any adopted Ratatui widget families (`Block`, `Paragraph`,
  `List`, `Table`, `Tabs`, `Chart`, `Sparkline`, `Gauge`, `LineGauge`,
  `Scrollbar`, `Canvas`, `BarChart`, `Calendar`, and custom widgets)
- symbol family chooser for borders, lines, markers, and bar/shade variants
- per-widget state styles (default/focus/selected/disabled/alert)

### S) Inspector and authoring assistance

- element inspector to reveal component ID + active style path
- quick-jump from selected UI element to Studio control page
- per-state preview scrubber (default/focus/selected/disabled/alert/voice-state)
- before/after diff preview for safe edits

### T) Visual rule engine (no-code automation)

- condition-based style overrides (`if state/data/capability then style variant`)
- threshold-driven widget styling (queue depth, latency bands, level bands)
- context routing (backend/project/profile) without manual pack switching
- explicit priority/conflict-resolution model for multiple matching rules

## Studio UX Architecture (No-Code)

Add dedicated `Theme Studio` mode with pages:

1. Home
2. Colors
3. Typography + Glyphs
4. Borders + Frames
5. Layout Builder
6. Widgets
7. Motion
8. Behavior
9. Keybinds
10. Accessibility
11. Profiles
12. Preview + Save/Export

`Settings` remains separate and non-theme by contract.

Interaction model:

- keyboard-first with mouse enhancement
- persistent draft state
- instant preview
- component inspector ("what is this styled by?") with jump-to-control action
- undo/redo stack
- apply vs save distinction
- rollback to last-known-good

## Settings-to-Studio Migration Contract

When Studio baseline is active, migrate these controls out of Settings:

- `SettingsItem::Theme`
- `SettingsItem::HudStyle`
- `SettingsItem::HudBorders`
- `SettingsItem::HudPanel`
- `SettingsItem::HudAnimate`

Reference source for current ownership: `src/src/bin/voiceterm/settings/items.rs`.

## Data Model Upgrade

Move from theme-only to style-pack model:

- `ThemeTokens`: colors/borders/glyph/text styles
- `LayoutProfile`: structure + responsive rules
- `WidgetProfile`: module composition + chart configs
- `MotionProfile`: animation channels + timings
- `BehaviorProfile`: visibility/update/interaction rules
- `ComponentSkinProfile`: style slots for buttons/tabs/list/table/tree/scrollbar/modal/input surfaces
- `StateMatrixProfile`: per-component interaction-state variants and transition deltas
- `LayeringProfile`: overlay stack ordering/occlusion and modal/backdrop policy
- `NotificationProfile`: toast/feedback visuals and history styling
- `CommandSurfaceProfile`: palette/autocomplete/search UI styling
- `VoiceStateProfile`: per-state scene visuals and transitions
- `AccessibilityProfile`: readability and fallback policies
- `StartupProfile`: splash/banner branding, logo treatment, startup status rows
- `WizardProfile`: calibration/setup overlay visuals and guidance rows
- `ProgressProfile`: determinate/indeterminate bars, spinners, queue badges
- `TextureProfile`: symbol textures, stepped gradients, optional image surfaces
- `WidgetPackProfile`: widget-pack registry, policy, and default style bindings
- `RuleProfile`: conditional style rules (state/data/capability driven overrides)
- `TerminalAdapterProfile`: optional host-terminal integration settings

Persist as versioned `StylePack` with inheritance and partial overrides.

## File/Module Plan

### New modules (proposed)

- `src/src/bin/voiceterm/theme/spec.rs`
- `src/src/bin/voiceterm/theme/runtime.rs`
- `src/src/bin/voiceterm/theme/registry.rs`
- `src/src/bin/voiceterm/theme/resolver.rs`
- `src/src/bin/voiceterm/theme/io.rs`
- `src/src/bin/voiceterm/theme/migrate.rs`
- `src/src/bin/voiceterm/theme/component_registry.rs` (styleable component IDs + defaults)
- `src/src/bin/voiceterm/studio/` (editor pages/state/actions)
- `src/src/bin/voiceterm/render_model/` (scene/layout/widget composition)
- `src/src/bin/voiceterm/keymap/` (runtime-editable keybinding profiles)
- `src/src/bin/voiceterm/profiles/` (backend/project profile resolution)

### Existing modules to refactor

- `src/src/bin/voiceterm/theme/mod.rs`
- `src/src/bin/voiceterm/theme/palettes.rs`
- `src/src/bin/voiceterm/config/theme.rs`
- `src/src/bin/voiceterm/settings/*`
- `src/src/bin/voiceterm/overlays.rs`
- `src/src/bin/voiceterm/buttons.rs`
- `src/src/bin/voiceterm/event_loop.rs`
- `src/src/bin/voiceterm/status_line/layout.rs`
- `src/src/bin/voiceterm/status_line/animation.rs`
- `src/src/bin/voiceterm/status_line/format.rs`
- `src/src/bin/voiceterm/writer/state.rs`

## Safe Rollout Plan (Do Not Break Overlay)

### Phase 0: Safety rails before expansion

- add golden snapshots for existing HUD layouts/themes
- add compatibility matrix tests for terminals/modes
- add migration test harness for style schema versions

Acceptance:

- baseline output parity protected by tests before new editor work

### Phase 1: Style engine foundation

- implement `StylePack` schema and runtime resolver
- convert built-ins to style packs internally
- keep UI behavior unchanged

Acceptance:

- all existing theme behavior remains intact

### Phase 2: Persistence and precedence

- preferences + style packs on disk
- project overrides + CLI precedence
- atomic writes + fallback on invalid specs

Acceptance:

- stable cross-restart behavior with tested precedence

### Phase 3: Runtime visual surface expansion (pre-Studio controls)

- complete visual runtime features first (before deep editor coverage):
  - toast notification center
  - command palette and autocomplete surfaces
  - session dashboard/multi-panel surfaces
  - expanded widget/state-visual surface coverage
  - expanded control-surface set (buttons/tabs/list/table/tree/scrollbar/modal/input visuals)
  - migrate startup/help/settings/picker/calibration/progress/icon surfaces into style-pack routing
- ensure each runtime visual surface is mapped into `StylePack` fields, even if
  defaults are temporarily applied before full Studio page controls

Acceptance:

- runtime visual surface set is present and style-pack addressable

### Phase 3.5: Framework parity and capability matrix

- lock Ratatui widget/symbol parity matrix for current shipped version and track
  upgrade deltas before enabling new visual controls
- add terminal capability matrix for color depth, keyboard enhancement flags,
  synchronized updates, and graphics protocol support
- define fallback guarantees for unsupported capabilities
- add dependency-compatibility matrix for third-party widget packs vs pinned
  Ratatui/Crossterm versions (upgrade path tracked before enabling packs)

Acceptance:

- framework-driven surfaces are all either Studio-controlled or tracked with
  explicit parity tasks and tested fallbacks

### Phase 4: Studio v1 (visual tokens + feedback surfaces)

- colors, borders, glyphs, text-style controls
- notification + command-surface styling controls
- live preview + save/duplicate/export

Acceptance:

- non-coder can fully restyle visuals end-to-end

### Phase 5: Studio v2 (layout + widgets)

- layout builder
- widget composer
- graph configuration panel

Acceptance:

- user can create distinct structural layouts and graph styles without code

### Phase 6: Studio v3 (motion + behavior + accessibility + voice-state scenes)

- motion channel editor
- behavior rules editor
- accessibility profiles
- per-state scene controls

Acceptance:

- user can control animation intensity and behavior per state

### Phase 6.5: Studio component-skin parity

- component skin editor pages for:
  - buttons and controls
  - tabs/list/table/tree/scrollbar
  - modal/popup/tooltip and input surfaces
- state-matrix editor for focus/hover/pressed/selected/disabled and success/warn/error variants

Acceptance:

- all runtime-rendered components have editable style + state controls in Studio

### Phase 7: Keybinds and profile routing

- no-code keymap editor
- backend/project profile selection

Acceptance:

- user can remap interactions and apply context-specific styles

### Phase 8: Terminal adapter layer (fonts and host-specific extras)

- optional adapters for WezTerm/Kitty/iTerm2/xterm-compatible flows
- explicit capability checks and opt-in guardrails

Acceptance:

- supported terminals can apply host-level extras from Studio
- unsupported terminals degrade cleanly

### Phase 9: Optional render-backend hardening

- evaluate Ratatui-buffer path for Studio overlays/widgets
- keep ANSI writer transport and PTY integrity

Acceptance:

- no PTY regressions, reduced render complexity where adopted

## "No-Code Promise" Rules

To keep this truly no-code:

1. Every persisted field in `StylePack` must have a Studio control.
2. Importing a pack must never require manual edits.
3. Every validation error must be shown with a guided fix action.
4. Every destructive action must have undo/rollback.
5. Studio must support keyboard-only workflows.
6. New visual runtime features cannot remain permanently outside Studio control.
7. Every renderable component must have a stable style ID in the component registry.
8. Every component state (focus/hover/pressed/selected/disabled/alert variants) must be styleable.
9. Every adopted Ratatui widget/symbol family must have style mapping and
   parity tests before release.
10. Any host-terminal-specific visual feature must ship with an explicit
    fallback chain and capability detection.
11. Every rendered element must be discoverable via inspector path -> style ID.
12. Every runtime conditional style rule must be editable/testable in Studio.

## Robustness and Guardrails

- strict schema validation and bounded numeric ranges
- capability-aware fallback for color/glyph/animation features
- last-known-good runtime fallback on invalid updates
- safe-mode startup flag if style loading fails repeatedly
- profile sanity checks before activation

## Overlay Coverage Contract (No Missing Visual Surfaces)

Each visual runtime feature must map to one `StylePack` profile area:

- TachyonFX transitions and state effects -> `MotionProfile`
- telemetry/graphs/widgets -> `WidgetProfile`
- toast notifications -> `NotificationProfile`
- voice-state scene visuals -> `VoiceStateProfile`
- command palette/autocomplete/search surfaces -> `CommandSurfaceProfile`
- dashboard/multi-panel layout surfaces -> `LayoutProfile` + `WidgetProfile`
- buttons/tabs/list/table/tree/scrollbar/modal/input surfaces -> `ComponentSkinProfile` + `StateMatrixProfile`
- overlay layer ordering/backdrop policy -> `LayeringProfile`
- startup splash/banner and startup status rows -> `StartupProfile`
- help/settings/theme-picker overlay chrome -> `CommandSurfaceProfile` + `ComponentSkinProfile`
- calibration wizard and mic meter visuals -> `WizardProfile` + `ProgressProfile`
- progress bars/spinners/queue badges -> `ProgressProfile` + `MotionProfile`
- icon packs/spinner glyph sets/meter glyphs -> `ThemeTokens` + `MotionProfile`
- texture/image surfaces and fallback strategy -> `TextureProfile` + `TerminalAdapterProfile`
- conditional visual automation and threshold overrides -> `RuleProfile`

If a runtime surface ships before its Studio page exists, track an explicit MP
parity task until UI control parity is complete.

## Future Feature Onboarding Contract (Visual)

For every newly added visual feature/component:

1. define a stable component ID and default style entry in `component_registry`
2. add `StylePack` schema fields (or map to existing fields)
3. wire resolver path (no hardcoded style constants in render path)
4. add Studio control mapping
5. add snapshot coverage for at least default + focused + selected states
6. add docs note for new style surface and fallback behavior
7. add capability matrix expectations for terminal-specific behavior
8. if Ratatui widget/symbol usage changes, update parity matrix + tests

## Quality Gates

Unit tests:

- schema parse/validate
- inheritance merge
- precedence rules
- migration steps
- fallback transforms

Integration tests:

- startup with preferences + overrides
- import/export roundtrip
- studio apply/save/rollback flows
- keymap/profile activation behavior
- component-registry -> stylepack -> studio control parity checks
- startup/help/settings/picker/calibration/progress surfaces resolve from stylepack
- terminal capability matrix behavior (truecolor/ansi256, graphics support, sync update support)

Snapshot tests:

- narrow/medium/wide renders
- all built-ins + sample custom packs
- per-state visual variants
- component-skin variants for buttons/tabs/table/list/tree/scrollbar/modal/input
- startup splash + help/settings/picker chrome variants
- calibration/progress/queue feedback variants

Performance checks:

- bounded render-time allocations
- bounded animation tick rates
- no unbounded buffers in hot paths

Repo gates:

- `python3 dev/scripts/devctl.py check --profile ci`
- `python3 dev/scripts/devctl.py docs-check --user-facing`
- `python3 dev/scripts/devctl.py hygiene`

CI policy additions:

- fail if any new renderable component lacks style ID registration
- fail if any style-pack field lacks a Studio control mapping after parity phase
- fail if new Ratatui widget/symbol usage lands without parity mapping
- fail if terminal-specific visuals land without capability fallback tests

## Theme Studio Definition of Done (Authoritative Checklist)

Authoritative gate definitions, MP-to-gate mapping, ownership matrix, and
mandatory Theme Studio verification bundle now live in
`dev/active/MASTER_PLAN.md` (Phase 2C) so execution and gate evidence are kept
in one active tracker.

Use this document for product architecture/spec details and keep execution state
updates in `MASTER_PLAN`.

## Risks and Mitigations

- Risk: Feature scope explosion slows delivery.
  - Mitigation: strict phased delivery with frozen acceptance per phase.
- Risk: Editor complexity harms reliability.
  - Mitigation: snapshot baselines, kill-switches, and staged flags.
- Risk: Terminal differences break "font-like" behavior.
  - Mitigation: adapter capability detection + explicit unsupported fallback.
- Risk: graphics/textures are inconsistent across terminals.
  - Mitigation: protocol capability probes + strict fallback chain (`image -> symbol texture -> plain`).
- Risk: Too many options overwhelm users.
  - Mitigation: presets first, advanced mode toggle, guided templates.

## Documentation Updates Required

When implemented, update:

- `dev/active/MASTER_PLAN.md`
- `dev/CHANGELOG.md`
- `guides/USAGE.md`
- `guides/CLI_FLAGS.md`
- `guides/TROUBLESHOOTING.md`
- `dev/ARCHITECTURE.md`

## References (Framework and Pattern Research)

- Ratatui layout concepts: <https://ratatui.rs/concepts/layout/>
- Ratatui widgets and custom widgets:
  <https://ratatui.rs/concepts/widgets/>
- Ratatui crate docs and markers/styles:
  <https://docs.rs/ratatui/latest/ratatui/>
- Ratatui widgets module index:
  <https://docs.rs/ratatui/latest/ratatui/widgets/index.html>
- Ratatui symbols module index:
  <https://docs.rs/ratatui/latest/ratatui/symbols/index.html>
- Ratatui style module:
  <https://docs.rs/ratatui/latest/ratatui/style/index.html>
- Ratatui feature flags:
  <https://ratatui.rs/concepts/features/>
- Crossterm event model:
  <https://docs.rs/crossterm/latest/crossterm/event/index.html>
- Crossterm key event kinds:
  <https://docs.rs/crossterm/latest/crossterm/event/enum.KeyEventKind.html>
- Crossterm keyboard enhancement flags:
  <https://docs.rs/crossterm/latest/crossterm/event/struct.PushKeyboardEnhancementFlags.html>
- Crossterm synchronized updates:
  <https://docs.rs/crossterm/latest/crossterm/terminal/struct.BeginSynchronizedUpdate.html>
- Crossterm color model:
  <https://docs.rs/crossterm/latest/crossterm/style/enum.Color.html>
- TachyonFX docs:
  <https://docs.rs/tachyonfx/latest/tachyonfx/>
- Ratatui third-party widgets list:
  <https://ratatui.rs/community/third-party-widgets/>
- `tui-popup` crate:
  <https://crates.io/crates/tui-popup>
- `tui-tree-widget` crate:
  <https://crates.io/crates/tui-tree-widget>
- `tui-textarea` crate:
  <https://crates.io/crates/tui-textarea>
- `ratatui-image` crate:
  <https://crates.io/crates/ratatui-image>
- `tui-widgets` ecosystem:
  <https://github.com/ratatui/tui-widgets>
- `tui-prompts` crate:
  <https://crates.io/crates/tui-prompts>
- `tui-scrollview` crate:
  <https://crates.io/crates/tui-scrollview>
- `tui-big-text` crate:
  <https://crates.io/crates/tui-big-text>
- `tui-qrcode` crate:
  <https://crates.io/crates/tui-qrcode>
- `throbber-widgets-tui` crate:
  <https://crates.io/crates/throbber-widgets-tui>
- `tui-markdown` crate:
  <https://crates.io/crates/tui-markdown>
- `ratatui-splash-screen` crate:
  <https://crates.io/crates/ratatui-splash-screen>
- `tuirealm` crate:
  <https://crates.io/crates/tuirealm>
- Helix theme model:
  <https://docs.helix-editor.com/themes.html>
- Zellij themes:
  <https://zellij.dev/documentation/themes>
- VS Code theme customization:
  <https://code.visualstudio.com/docs/configure/themes>
- xterm control sequences (`allowFontOps`, OSC 50 context):
  <https://invisible-island.net/xterm/ctlseqs/ctlseqs.html>
- iTerm2 escape codes and profile notes:
  <https://iterm2.com/documentation-escape-codes.html>
- Kitty remote control protocol:
  <https://sw.kovidgoyal.net/kitty/rc_protocol/>
- Kitty graphics protocol:
  <https://sw.kovidgoyal.net/kitty/graphics-protocol/>
- iTerm2 inline images:
  <https://iterm2.com/documentation-images.html>
- WezTerm runtime config overrides:
  <https://wezterm.org/config/lua/window/set_config_overrides.html>
